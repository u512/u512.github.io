<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Wireshark分析艺术【转载】 | XiaoEr</title><meta name="keywords" content="tcp/ip,wireshark"><meta name="author" content="XiaoEr,448778313@qq.com"><meta name="copyright" content="XiaoEr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="转载自: https:&#x2F;&#x2F;blog.51cto.com&#x2F;u_15127514&#x2F;2680191 Wireshark实战操作界面的操作分析三板斧之一：查看统计、属性信息 性能分析三板斧之一： 【统计-&gt;捕获文件属性】 Statistics -&gt; Summary，查看文件属性信息，如平均速度、包大小、包数等等 判断流量高低峰、是否过载 三板斧之二：查看分析专家信息 性能分析三板斧之">
<meta property="og:type" content="article">
<meta property="og:title" content="Wireshark分析艺术【转载】">
<meta property="og:url" content="https://w512.gitee.io/2022/07/21/2022-07-21-wireshark-for-tcp/index.html">
<meta property="og:site_name" content="XiaoEr">
<meta property="og:description" content="转载自: https:&#x2F;&#x2F;blog.51cto.com&#x2F;u_15127514&#x2F;2680191 Wireshark实战操作界面的操作分析三板斧之一：查看统计、属性信息 性能分析三板斧之一： 【统计-&gt;捕获文件属性】 Statistics -&gt; Summary，查看文件属性信息，如平均速度、包大小、包数等等 判断流量高低峰、是否过载 三板斧之二：查看分析专家信息 性能分析三板斧之">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-07-20T23:28:16.000Z">
<meta property="article:modified_time" content="2022-07-20T23:55:15.290Z">
<meta property="article:author" content="XiaoEr">
<meta property="article:tag" content="tcp&#x2F;ip">
<meta property="article:tag" content="wireshark">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://w512.gitee.io/2022/07/21/2022-07-21-wireshark-for-tcp/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Wireshark分析艺术【转载】',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-21 07:55:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/header.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XiaoEr</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Wireshark分析艺术【转载】</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-20T23:28:16.000Z" title="发表于 2022-07-21 07:28:16">2022-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-20T23:55:15.290Z" title="更新于 2022-07-21 07:55:15">2022-07-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/tcp-ip/">tcp/ip</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Wireshark分析艺术【转载】"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>转载自: <a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127514/2680191">https://blog.51cto.com/u_15127514&#x2F;2680191</a></p>
<h1 id="Wireshark实战操作"><a href="#Wireshark实战操作" class="headerlink" title="Wireshark实战操作"></a>Wireshark实战操作</h1><h2 id="界面的操作分析"><a href="#界面的操作分析" class="headerlink" title="界面的操作分析"></a>界面的操作分析</h2><p><strong>三板斧之一：查看统计、属性信息</strong></p>
<p>性能分析三板斧之一：</p>
<p>【统计-&gt;捕获文件属性】 Statistics -&gt; Summary，查看文件属性信息，如平均速度、包大小、包数等等</p>
<p>判断流量高低峰、是否过载</p>
<p><strong>三板斧之二：查看分析专家信息</strong></p>
<p>性能分析三板斧之二：</p>
<p>【分析-&gt;专家信息】 Wireshark -&gt;Analyze -&gt; Expert Infos -&gt; Notes，查看抓包的统计信息</p>
<p>查看是否有Notes、Warnings、errors之类的信息，看看是否有相关警告和错误，判断网络质量、重传乱序等</p>
<p><strong>三板斧之三：查看服务响应时间</strong></p>
<p>性能分析三板斧之三：</p>
<p>【统计-&gt;服务响应时间】 statistics -&gt; Service Response Time -&gt; xxxxx（如：ONC-RPC -&gt; Program:NFS）</p>
<p>查看各项操作的服务响应时间，判断是否过载</p>
<p><strong>将seq使用相对值来替代真实值</strong></p>
<p>Edit-&gt;Preferences-&gt;Protocols-&gt;TCP,勾选 Relative Sequence Numbers</p>
<p>启用之前就是相对值了。</p>
<p><strong>查看TCP StreamGraph</strong></p>
<p>Statistics -&gt; TCP StreamGraph -&gt; TCP Sequence Graph（Stevens）</p>
<p>查看数据传输情况，如传输的是否均匀、是否有TCP Zero Windows之类的</p>
<h2 id="字段含义-amp-提示信息"><a href="#字段含义-amp-提示信息" class="headerlink" title="字段含义&amp;提示信息"></a>字段含义&amp;提示信息</h2><p>字段含义就是wireshark的一些提示信息,也就是wireshark抓包的一些info信息，这些提示信息都是Info这一栏中体现。</p>
<p><strong>1. [Packer size limited during caputre]</strong></p>
<p>如果某个包被标记提示[Packer size limited during caputre]，说明这个包没有抓全，可以进一步查看下面的frame信息。一般这个情况是抓包的姿势不对。某些操作系统中，tcpdump默认只抓取每个帧的前96个字节，因此tcpdump抓包的时候，可以通过 -s参数指定要抓取的字节数</p>
<p><strong>2. [TCP ACKed unseen segment]</strong></p>
<p>如果wireshark发现被Ack的那个包没有抓到，就会提示[TCP ACKed unseen segment]，不过这个提示大部分情况都可以忽略。因为大都情况下，刚开始抓包的时候，都是只抓到了后面的Ack而没有抓到前面的ACK</p>
<p><strong>3. [TCP Previous segment not captured]</strong><br>TCP数据传输中，除了三次握手和四次握手之外，同一台机器发出的数据段应该是连续的，即后一个包的Seq等于前一个包的Seq+Len，正确情况都应该是这样；如果发现后一个包的Seq大于前一个包的Seq+Len，那么就说明中间丢了一段数据，如果丢失的数据在整个网络包中都找不到，wireshark就会提示[TCP Previous segment not captured]，</p>
<p>出现这种情况的两个可能性：</p>
<p>数据包真的丢了<br>数据包并没有真丢，只是抓包工具漏掉了<br>如果确认Ack包中包含了没有抓到的包，那就是抓包工具漏掉了，否则就是真丢了</p>
<p><strong>4. [TCP Out-of-Order]</strong></p>
<p>TCP数据传输中，除了三次握手和四次握手之外，同一台机器发出的数据段应该是连续的，即后一个包的Seq等于前一个包的Seq+Len，正确情况都应该是这样；或者说后一个包的Seq应该会大于等于前一个包的Seq+Len，如果wireshark发现后一个包的Seq小于前一个包的Seq+Len，那么就认为是乱序了，就会提示[TCP Out-of-Order]。</p>
<p>一般而言，小跨度的乱序影响不大，如果是大跨度的乱序则会导致快速重传。举例如下，如果一个包的顺序是1、2、3、4、5被打乱成2、1、3、4、5则属于小跨度乱序，影响不大；如果被打乱成2、3、4、5、1，则会触发足够多的Dup ACK，从而导致1号包的重传。</p>
<p><strong>5. [TCP Dup ACK]</strong></p>
<p>当乱序或者丢包发生时，接收方就会收到一些Seq号比期望值大的包，TCP协议每收到一个这种包就会ACK一次期望的Seq值，通过这个方式告知发送方，因此就产生了一些重复的Ack。Wireshark抓到这些重复的Ack就会提示[TCP Dup ACK].</p>
<p><strong>6. [TCP Fast Retransmission]</strong></p>
<p>当发送方连续收到3个或者以上[TCP Dup ACK]时，就意识到之前发的包可能丢了，于是根据RFC的规定就会开始快速重传。[TCP Dup ACK]是接收方回应给发送方的，因此发送方就能够感知到并当连续收到3个以上的时候就开启快速重传。</p>
<p>快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计数器时间到期。</p>
<p><strong>7. [TCP Retransmission]</strong></p>
<p>如果一个包真的丢了，又没有后续包可以在接收方触发[Dup Ack]，那么就不会开启快速重传，这种情况发送方只能等到超时后再发送重传，超时重传的包就会被wireshark标记并提示[TCP Retransmission]</p>
<p>TCP 超时与重传应该是 TCP 最复杂的部分之一，超时重传是 TCP 保证可靠传输的基础。当 TCP 在发送数据时，数据和 ack 都有可能会丢失，因此，TCP 通过在发送时设置一个定时器来解决这种问题。如果定时器溢出还没有收到确认，它就重传数据。关键之处就在于超时和重传的策略，需要考虑两方面：</p>
<p>超时时间设置<br>重传的频率（次数）<br>在 Linux 较高的内核版本中，比如 3.15 中，已经有了至少 9 个定时器：超时重传定时器，持续定时器，ER延迟定时器，PTO定时器，ACK延迟定时器，SYNACK定时器，保活定时器，FIN_WAIT2定时器，TIME_WAIT定时器。</p>
<p><strong>8. [TCP zerowindow]</strong></p>
<p>TCP包中“win&#x3D;xxx”代表接收窗口的大小，表示这个包的发送方当前还有多少缓冲区可以接受数据。当wireshark发行一个包中的“win&#x3D;0”时，就会标记提示[TCP zerowindow]，表示缓冲区已经满了，无法再接收数据了。</p>
<p>一般的，在缓冲区满之前，窗口大小应该是逐渐减小的过程。</p>
<p><strong>9. [TCP window Full]</strong></p>
<p>如果一个包的发送方已经把对方所声明的接收窗口大小耗尽了，就会被wireshark标记为[TCP window Full]。比如某一端在握手时声明自己的接收窗口只有65535，也就意味着对端最多只能给他发送65535字节的数据而无需确认，即“在途字节数”最多只能是65535，当wireshark计算出对端已经有65535字节未被确认时，就会发生这个提示。</p>
<p>[TCP window Full]和上面的[TCP zerowindow]比较容易混淆，前者表示这个包的发送方暂时没有办法再发送数据了；后者表示这个包的发送方没有办法再接收数据了；两者都会意味着要暂停数据传输</p>
<p><strong>10. [TCP segment of reassembled PDU]</strong></p>
<p>只有在Edit-&gt;Preferences-&gt;Protocols-&gt;TCP菜单里启用了Allow sub dissector to reassemble TCP streams后，才有可能收到这个提示。这个表示可以把属于同一个应用层PDU的TCP包虚拟的集中起来</p>
<p><strong>11. [Continuation to #]</strong></p>
<p>只有在Edit-&gt;Preferences-&gt;Protocols-&gt;TCP菜单里关闭了Allow sub dissector to reassemble TCP streams后，才有可能收到这个提示。</p>
<p><strong>12. [Time-to-live-exceeded(Fragment reasembly time execeeded)]</strong></p>
<p>（Fragment reasembly time execeeded）表示这个包的发送方之前收到了一些分片，但是由于某些原因导致迟迟无法组装起来。</p>
<p>比如传输过程中有一些分片被丢包了，那么接收方就无法组装起来，然后就通过这个ICMP的方式告知发送方</p>
<p>ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP&#x2F;IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<h1 id="Wireshark分析TCP协议"><a href="#Wireshark分析TCP协议" class="headerlink" title="Wireshark分析TCP协议"></a>Wireshark分析TCP协议</h1><h2 id="TCP抓包协议基础"><a href="#TCP抓包协议基础" class="headerlink" title="TCP抓包协议基础"></a>TCP抓包协议基础</h2><h3 id="TCP控制字段"><a href="#TCP控制字段" class="headerlink" title="TCP控制字段"></a>TCP控制字段</h3><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.</p>
<p>抓包显示的控制字段形态如下：</p>
<p>[SYN]： 建立连接、发起包<br>[FIN]： 关闭连接、结束包<br>[PSH]： DATA数据传输<br>[ACK]： ACK回应<br>[RST]： RESET、连接重置</p>
<p>另外两个常用字段：</p>
<p>[Len]：数据包长度<br>[Seq]：数据包序列号</p>
<p>ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接之后的响应，如果只是单个的一个SYN，它表 示的只是建立连接</p>
<p>当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接 当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接</p>
<h3 id="抓包方向（client-or-server）"><a href="#抓包方向（client-or-server）" class="headerlink" title="抓包方向（client or server）"></a>抓包方向（client or server）</h3><p>抓包的时候，不管是通过wireshark抓包，还是通过tcpdump抓包，都需要看看是从客户端方向抓包，还是从服务端方向抓包，不同的方向，抓包的情况完全不一样，因为网络（公网、实际环境）上有很多异常情况发生。</p>
<h3 id="TCP的Ack"><a href="#TCP的Ack" class="headerlink" title="TCP的Ack"></a>TCP的Ack</h3><p>对应http而言，一般就是request-&gt;reponse，一问一答。但对应TCP而言，并不一定每个包都会ACK。TCP的ACK是一种累积的ACK，也就是表示在我这个ACK之前的所有其他ACK都已经确认收到了。</p>
<p>比如，97号包的ACK&#x3D;65701，96号包的Seq+Len&#x3D;64273+1428&#x3D;65701，那么就是表示97号的ACK是对96号的回应，也就是96号之前的其他没有被显示ACK的包，其实都已经通过97号包ACK了，这样发送方也就知道了在96号之前发出去的所有包对方都已经收到并ACK了。</p>
<h3 id="MSL、TTL、RTT"><a href="#MSL、TTL、RTT" class="headerlink" title="MSL、TTL、RTT"></a>MSL、TTL、RTT</h3><p>MSL（Maximum Segment Lifetime），表示“报文最大生存时间”，是所有报文都遵循的在网络上存在的最长时间，超过这个时间报文将被丢弃</p>
<p>RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。<br>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态<br>TTL（Time to live），表示生存时间，是ip头的一个域，生存时间是由源主机来设置一个初始值，但TTL不是存的具体时间，而是表示可以经过的最大路由数。</p>
<p>根据RFC 1812，一个网络包的TTL每减去1就表示它经过一次路由。一般TTL的初始值为64，如果某个ACK包的TTL是62，则意味着是是距离此设备两跳的设备发出来的。<br>TTL在wireshark抓包中的形态如Time to live: 62<br>TTL&#x3D;0则数据报将被丢弃，同时发送ICMP报文通知源主机<br>一般在缓存、连接心跳中也用到TTL这个，他们和TCP协议中的TTL是有区别的，缓存、连接心跳中的TTL表示的就是数据缓存or剩余的时间。<br>RTT（round-trip time），表示客户到服务器往返所花时间，TCP含有动态估算RTT的算法</p>
<p>TCP会持续估算一个给定连接的RTT，因为RTT受网络传输拥塞程序的变化而变化</p>
<h3 id="MAC地址解析"><a href="#MAC地址解析" class="headerlink" title="MAC地址解析"></a>MAC地址解析</h3><p>Protocol &#x3D; ARP Source 和 Destination 都是MAC地址格式如 00:60:48:ff:12:31</p>
<p>抓包分析中，如果网络不通，发出去收不到ACK等等之类的，要再进一步看看每个包的MAC地址是否正确，反之有多个MAC地址导致的一些问题</p>
<h2 id="TCP握手和挥手协议"><a href="#TCP握手和挥手协议" class="headerlink" title="TCP握手和挥手协议"></a>TCP握手和挥手协议</h2><h3 id="TCP三次握手-amp-判断回包"><a href="#TCP三次握手-amp-判断回包" class="headerlink" title="TCP三次握手&amp;判断回包"></a>TCP三次握手&amp;判断回包</h3><p>三次握手协议</p>
<p>client-&gt;server : [SYN] Seq&#x3D;X  win&#x3D;xxx Len&#x3D;0 MSS&#x3D;xxx<br>server-&gt;client : [SYN, ACK] Seq&#x3D;Y，ACK&#x3D;X+1 win&#x3D;xxx Len&#x3D;0 MSS&#x3D;xxx<br>client-&gt;server : [ACK] Seq&#x3D;X+1，Ack&#x3D;Y+1 win&#x3D;xxx Len&#x3D;0<br>抓包数据，如何判断一个包是上一个包的回包呢？根据TCP协议，下一个包的Ack的值如果等于上一个包的Seq + Len，则表示是其回包</p>
<p>上一个和下一个，很多情况下并不是连续的，也行下一个回包距离上一个包已经过了很多包了，因为重传、延迟的原因的<br>三次握手的时候会相互声明各自的MSS</p>
<h3 id="TCP四次挥手-amp-三次挥手"><a href="#TCP四次挥手-amp-三次挥手" class="headerlink" title="TCP四次挥手&amp;三次挥手"></a>TCP四次挥手&amp;三次挥手</h3><p>TCP四次挥手协议</p>
<p>client-&gt;server : FIN Seq&#x3D;X，ACK&#x3D;Y<br>server-&gt;client : Seq&#x3D;Y，ACK&#x3D;X+1<br>server-&gt;client : FIN Seq&#x3D;Y，ACK&#x3D;X+1<br>client-&gt;server : Seq&#x3D;X+1，Ack&#x3D;Y+1<br>正常而言，都会有这样的四次挥手，但是如果有延迟确认，那么四次挥手就变成了3次挥手，省掉了四次挥手中的第二个包</p>
<p>client-&gt;server : FIN Seq&#x3D;X，ACK&#x3D;Y<br>server-&gt;client : FIN Seq&#x3D;Y，ACK&#x3D;X+1<br>client-&gt;server : Seq&#x3D;X+1，Ack&#x3D;Y+1</p>
<h2 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h2><h3 id="在途字节数"><a href="#在途字节数" class="headerlink" title="在途字节数"></a>在途字节数</h3><p>在途字节数【bytes in flight】，表示的是已经发送出去，但是还没有被确认的字节数，这个确认指的是对端发出ACK确认，这个就是所谓的网络承载量；如果在途字节数超过网络承载量，那么就会发生丢包重传<br>这个“当前”仅仅从抓包上的网络包序号去看就可以了，并不需要这两个包有什么关系，也正因为这两个包没有关系，所以才是计算出在途字节数的方式<br>这个Len，一般而言，不应该超过TCP的MSS（最大数据字段），这个值是1388，注意对比MTU（1500）<br>在途字节数 &#x3D; 当前发送方的【Seq + Len】 - 当前接收方的【ACK】</p>
<h3 id="网络拥塞"><a href="#网络拥塞" class="headerlink" title="网络拥塞"></a>网络拥塞</h3><p>网络拥塞点：超过网络承载量而导致的网络拥塞。发生拥塞时的在途字节数就是该时刻的网络拥塞点，估算网络拥塞点只需要简单找到拥塞时的在途字节数即可<br>从发送方的视角，相当于是站在了CPU视角，这样抓包看到的应该是分段前的打包。从接收方视角，相当于是站在了网卡视角，那么看到的就应该是分段后的多个小包<br>LSO出现的意义在于目前网卡经常是千兆、万兆，这样CPU的负担很重。比如625MB&#x2F;s的网络流量大约需要耗费5GHz的CPU，因此为了缓解CPU的负担，就把一些分段的工作直接交给网卡去执行了，<br>取最小值是因为这样最保守，这样才能真正保证网络不会拥塞；取完之后要设置Linux的发送窗口<br>假如Seq+Len-Ack &#x3D; 103122，这个单位表示字节，也就是100KB，这个100KB就是最大的发送窗口，因此需要设置Linux系统中发送窗口的值<br>拥塞的特征就是连串的丢包、丢包后又会重传；wireshark、tcpdump等抓包工具可以标识出重传包<br>根据抓包工具，找到一连串重传包中的第一个包，然后根据该包重传的Seq值找到对应的原始包，最后，计算该原始包发送时刻的在途字节数，这个就标识当前的拥塞点<br>Wireshark -&gt;Analyze -&gt; Expert Info -&gt; Notes菜单可以看到重传统计<br>通过在途字节数只是估算 网络拥塞点，并不一定很精确，可以采样多次然后找到合适的值；多次采样后的数据，其实保守的话应该取最小值而不是平均值<br>前面有说的，数据包的Len最大不应该超过1388，但是实际抓包分析过程中，却会发现实际的Len可能是1338的两倍或者N倍，这个是什么原因呢？ 这是因为有一个所谓的LSO。<br>一般网络工作方式是：应用层把产生的数据交给TCP层，TCP再根据MSS大小进行分段，分段由CPU负责进行，最后再交给网卡<br>如果启用了LSO：TCP层就把大于MSS的数据块直接交给了网卡，让网卡去负责分段工作。<br>一些实战经验告诉我们，Wireshark -&gt;Analyze -&gt; Expert Info -&gt; Notes统计中的重传率如果超过了0.1%，就需要采取一些措施了。但是现实网络环境下，要低于0.01%的重传是基本不可能的。</p>
<h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><p>客户端发送窗口的两个因素：网络上的拥塞窗口（cwnd）和服务器上的接收窗口<br>如果是“慢启动”阶段，那么下一个RTT的包的cwnd应该要远远大于上一个包的cwnd<br>如果是“拥塞避免”阶段，那么下一个RTT的包的cwnd应该要增加一个MSS（以太网中的MSS约为1460字节）。<br>如果不符合上述两种情况，比如cwnd增长的非常慢，那么就需要根据cwnd的计算方式去分析了<br>cwnd的增长方式是：先“慢启动”、再进入“拥塞避免”，前者起点低但是能够快速增长、后者起点高但是每一个RTT只能增加一个MSS（RTT指往返时间，也就是到了下一个从同一个方向传输的包）<br>根据抓包的数据，点开详情，查看其“Bytes in flight”值，可以简单等同与cwnd</p>
<h3 id="TCP-Nagle算法和延迟确认Delayed-ACK"><a href="#TCP-Nagle算法和延迟确认Delayed-ACK" class="headerlink" title="TCP Nagle算法和延迟确认Delayed ACK"></a>TCP Nagle算法和延迟确认Delayed ACK</h3><ol>
<li>Nagle算法：<br>是为了减少广域网的小分组数目，从而减小网络拥塞的出现；</li>
</ol>
<p>该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组；</p>
<p>该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> there is a new data to send</span><br><span class="line">    <span class="keyword">if</span> the window size &gt;= MSS and available data is &gt;= MSS</span><br><span class="line">        send complete MSS segment now</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> there is unconfirmed data still in the pipe</span><br><span class="line">            enqueue data in the buffer util an acknowledge is received</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            send data immediately</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>2.延迟ACK：</p>
<p>如果tcp对每个数据包都发送一个ack确认，那么只是一个单独的数据包为了发送一个ack代价比较高，所以tcp会延迟一段时间，如果这段时间内有数据发送到对端，则捎带发送ack，如果在延迟ack定时器触发时候，发现ack尚未发送，则立即单独发送；</p>
<p>延迟ACK好处：</p>
<p>(1) 避免糊涂窗口综合症； (2) 发送数据的时候将ack捎带发送，不必单独发送ack； (3) 如果延迟时间内有多个数据段到达，那么允许协议栈发送一个ack确认多个报文段；</p>
<ol start="3">
<li>当Nagle遇上延迟ACK：</li>
</ol>
<p>试想如下典型操作，写-写-读，即通过多个写小片数据向对端发送单个逻辑的操作，两次写数据长度小于MSS，当第一次写数据到达对端后，对端延迟ack，不发送ack，而本端因为要发送的数据长度小于MSS，所以nagle算法起作用，数据并不会立即发送，而是等待对端发送的第一次数据确认ack；这样的情况下，需要等待对端超时发送ack，然后本段才能发送第二次写的数据，从而造成延迟；</p>
<ol start="4">
<li>关闭Nagle算法：</li>
</ol>
<p>使用TCP套接字选项TCP_NODELAY可以关闭套接字选项;</p>
<p>如下场景考虑关闭Nagle算法：</p>
<p>(1) 对端不向本端发送数据，并且对延时比较敏感的操作；这种操作没法捎带ack； (2) 如上写-写-读操作；对于此种情况，优先使用其他方式，而不是关闭Nagle算法：</p>
<h2 id="TCP和UDP的区别、对比"><a href="#TCP和UDP的区别、对比" class="headerlink" title="TCP和UDP的区别、对比"></a>TCP和UDP的区别、对比</h2><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><p>TCP和UDP的区别如TCP是可靠的、UDP是不可靠的，但是实际中的表现是何为可靠？何为不可靠？具体协议的ACK有何区别？</p>
<p>不管对于TCP还是UDP，都可能会被分片，这是由于以太网的MSS决定的；不同在于分片传输的处理：</p>
<p>UDP而言，如果分片传输导致某些分片丢失，则接收方无法完成重组，这样发送方会将所有分片重传，如果发生重传则效率就会比较低。<br>UDP不可靠就在于此，没有一个机制保证数据被安全送达，需要应用层去负责重传<br>TCP而言，TCP的分段机制可以把数据包拆小后封装在多个包里，这样就避免了被网络层分片。重传而言，TCP只需要重传丢失的那个包而不需要重传整个包<br>TCP可靠也在于此，TCP会有机制保证数据被安全送达，而不需要应用层去处理重传<br>因为TCP只会重传丢失的某个包而不是整个包，因此重传效率比UDP高很多</p>
<h3 id="UDP-比-TCP-更适合语音"><a href="#UDP-比-TCP-更适合语音" class="headerlink" title="UDP 比 TCP 更适合语音"></a>UDP 比 TCP 更适合语音</h3><p>语音通话的场景在于不能接受延迟，但是可以接受音质稍差。这样的话，UDP传输的时候，如果有些包丢失，应用层可以选择忽略并继续传输其他包，丢到一些包只会影响到音质，但是保证了流畅性。TCP而言，会重传每个包，只要丢包就重传，这样就会导致有一定的延迟，在语音中如果有延迟则并不可取。</p>
<p>因此，TCP和UDP，各自有各自的适合场景。 语音、视频中，UDP更合适，像声网、linphone等都是UDP去处理音视频。 基础、核心协议交互中必须采用TCP。</p>
<h3 id="TCP和UDP的效率问题"><a href="#TCP和UDP的效率问题" class="headerlink" title="TCP和UDP的效率问题"></a>TCP和UDP的效率问题</h3><p>TCP在传输过程都需要往返时间来确认也就是ACK，而UDP则无需确认，那么UDP的效率一定比TCP高吗？这个是不一定的，虽然UDP可以一直往外不停的发包，不用等待ACK；但是TCP有发送窗口的存在，如果发送窗口小，并没有占满带宽，那么肯定受到往返时间的约束使得效率稍低，但是如果只要窗口足够大并且合适，跑满带宽，那么TCP也是可以不受往返时间的约束而源源不断的传输数据。</p>
<p>举例：马路上只有一辆车来回跑去拉货，回程过程相当于空跑（回程相当于TCP的ACK），这样TCP的效率当然低。但是如果在不拥塞的情况下，尽量提高车辆数量，是的马路上的车被刚好充满，这样总体的传输效率提高了，并且回程的ACK也不受影响。</p>
<h2 id="数据包分片、MTU、MSS"><a href="#数据包分片、MTU、MSS" class="headerlink" title="数据包分片、MTU、MSS"></a>数据包分片、MTU、MSS</h2><h3 id="数据包分片和重组"><a href="#数据包分片和重组" class="headerlink" title="数据包分片和重组"></a>数据包分片和重组</h3><p>分组交换，把大的数据分割成小包，这样可以实现链路共享，而不至于因为某一方阻塞所有。既然要分割成小包，那么必然要确定一个最大的包大小，这个就是MTU（Maximum Transmission Unit）最大传输单位，值为1500字节。如果除去20个字节的包头结构，那么一个IP包最大的包大小为1500-20&#x3D;1480字节。如果要传输的数据块超过1480字节，那么网络层就会将其分片处理，封装为多个网络包传输。对于TCP而言，TCP协议层会主动把数据分成小段后再交给网络层，TCP的最大分段大小称之为MSS（Maximum Segment Size），这个MSS被设置为MTU减去IP头和TCP头之后的大小，这样刚好可以满足一个MTU。因为UDP没有MSS的概念，因此就只能交给网络层去处理分片了。</p>
<p>但是需要注意的是，目前有些网络是Jumbo Frame（巨帧）或者PPPOE这样的设备，那么他们的MTU则不是1500字节。目前发送方并没有一个好的机制来确定最佳分片大小，应该尽量使得网络中的设备的MTU保持一致。如果网络中的设备的MTU不一致，那么TCP协议如何适配MTU呢？我们知道TCP建连的时候必须要先进行三次握手，TCP在前两个握手包中会相互声明自己的MSS。如果client端声明自己的MSS&#x3D;8960（巨帧），server端申明自己的MSS&#x3D;1460，那么client在三次握手后就知道了server端的MSS，因此当client想要发送大于server端MSS的包的时候就会主动将自己的MSS降低为server端的MSS大小，从而适配接收方的MTU，可见，TCP协议层做了非常多的优化和处理</p>
<p>既然有分片，那么接收方必然要进行分片重组，通过抓包工具可以得知，分片的每个包都包含了off&#x3D;xxx，ID&#x3D;xxx这样的信息，接收方会把ID相同的分片按照off偏移量进行重组。那么接收方又如何得知那个包才是最后的分片呢？然后什么时候开始重组呢？这里就在于最后一个分片包有一个特殊的Flag，叫More fragment &#x3D; 0，抓包中的表现形式是..0. … &#x3D; More fragment: Not set，这个就表示它是最后一个分片，然后可以开始重组包了。如果是其他分片包，形如..1. … &#x3D; More fragment: set则表示接收方需要缓存，等待其他分片传输完成</p>
<h3 id="MTU的实战"><a href="#MTU的实战" class="headerlink" title="MTU的实战"></a>MTU的实战</h3><p>如果client端的MTU&#x3D;9000，server端的MTU&#x3D;1500，那么当client请求server端的时候，client的包经过路由器时候，要么就被丢包，要么就被分片。如果这个巨帧包在网络层携带了DF（Don’t fragment）标志则被丢弃（设置则表示不允许分片），如果没有设置则进行分片传输。需要注意的是，这种情况下如果丢包了重传还是会被丢弃，就成了黑洞了。</p>
<p>测试中，可以通过ping命令模拟这样的情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：ping xxx.xxx.xxx.xxx -l 1472 -f -n 1</span><br><span class="line">失败：ping xxx.xxx.xxx.xxx -l 1473 -f -n 1</span><br></pre></td></tr></table></figure>
<p>-f 参数表示设置DF标志 -l 参数表示请求字节</p>
<p>当请求字节设置为1472的时候，因为ICMP头部为8字节、IP头为20字节，因此1472+8+20&#x3D;1500，刚好是一个MTU，因此可以ping成功。但是第二个1473+8+20&#x3D;1501字节超过MTU了，又因为设置了DF标志表示不允许分片，因此传输失败，一般这样的情况下，路由器会回复Packet needs to be fragmented but DF set。</p>
<p>抓包的时候，如果发现一直重传，某个某些相对较大的包（查看Len值）才重传，那么可以通过ping xxx.xxx.xxx.xxx -l [Len] -f值进行测试验证，通过这个ping指定的[Len]的大小变化来寻得规律，可能就会发现网络上某个设备的MTU并非1500，这样导致了超过这个就重传的现象。</p>
<h2 id="特殊的流控和带宽"><a href="#特殊的流控和带宽" class="headerlink" title="特殊的流控和带宽"></a>特殊的流控和带宽</h2><p>client 和 server端直接一定有交换机、路由器等设备，如果server端是万兆网卡，client端是千兆网卡，就有可能使得server端发送过快导致数据堵在交换机上，从而交换机在堵满之后发生丢包。但是一般而言，server端的带宽本应该要大于client端才算合理，为了避免拥塞，因此需要有一种流控机制，允许交换机在过载时告知server端放慢速度或者暂停传输。</p>
<p>有一种“暂停帧”，就能够满足这样的需求：当交换机的缓冲区即将被填满时发送给server端一个暂停帧，当server端等待一会儿再发，这样就可以避免溢出丢包，也避免丢包后的重传。server端等待多久则由暂停帧中的pause_time指定，这样server端在等待pause_time后才会开始继续发送。当然交换机还可以给server端发送一个pause_time&#x3D;0的暂停帧，告知server端，我已经消化完了，可以立即发送了。</p>
<p>注意，这的流控和TCP的流控是不一样的</p>
<h1 id="Wireshark分析方法论"><a href="#Wireshark分析方法论" class="headerlink" title="Wireshark分析方法论"></a>Wireshark分析方法论</h1><p>通过wireshark排查问题，需要分析网络包，在网络包中寻找一些线索，然后根据网络协议作出推断，接着就是一个一个去否定，然后最终找到问题所在</p>
<p>需要能够理解底层TCP协议，要能够清楚每一个字段表示的含义</p>
<p>要善用Wireshark的一些统计、分析工具；过滤器等</p>
<p>发送发抓包和接收抓包是有极大区别的</p>
<p>要善用“三板斧“的操作流程和步骤去分析问题</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://w512.gitee.io">XiaoEr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://w512.gitee.io/2022/07/21/2022-07-21-wireshark-for-tcp/">https://w512.gitee.io/2022/07/21/2022-07-21-wireshark-for-tcp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://w512.gitee.io" target="_blank">XiaoEr</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tcp-ip/">tcp/ip</a><a class="post-meta__tags" href="/tags/wireshark/">wireshark</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/24/2022-10-24_os_course_introduction/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MIT 6.s81课程学习(1) —— 简介</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/30/2022-05-30-aarch64-qemu-linux/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于QEMU的AArch64仿真环境运行Linux平台搭建</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/header.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XiaoEr</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/w512"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">自制力 + 执行力</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Wireshark%E5%AE%9E%E6%88%98%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">Wireshark实战操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E7%9A%84%E6%93%8D%E4%BD%9C%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">界面的操作分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89-amp-%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.</span> <span class="toc-text">字段含义&amp;提示信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Wireshark%E5%88%86%E6%9E%90TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.</span> <span class="toc-text">Wireshark分析TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8A%93%E5%8C%85%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">TCP抓包协议基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8E%A7%E5%88%B6%E5%AD%97%E6%AE%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">TCP控制字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%93%E5%8C%85%E6%96%B9%E5%90%91%EF%BC%88client-or-server%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">抓包方向（client or server）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84Ack"><span class="toc-number">2.1.3.</span> <span class="toc-text">TCP的Ack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MSL%E3%80%81TTL%E3%80%81RTT"><span class="toc-number">2.1.4.</span> <span class="toc-text">MSL、TTL、RTT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.5.</span> <span class="toc-text">MAC地址解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8F%A1%E6%89%8B%E5%92%8C%E6%8C%A5%E6%89%8B%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.</span> <span class="toc-text">TCP握手和挥手协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-amp-%E5%88%A4%E6%96%AD%E5%9B%9E%E5%8C%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">TCP三次握手&amp;判断回包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-amp-%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">TCP四次挥手&amp;三次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">TCP拥塞控制算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%80%94%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">在途字节数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E"><span class="toc-number">2.3.2.</span> <span class="toc-text">网络拥塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3"><span class="toc-number">2.3.3.</span> <span class="toc-text">发送窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-Nagle%E7%AE%97%E6%B3%95%E5%92%8C%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4Delayed-ACK"><span class="toc-number">2.3.4.</span> <span class="toc-text">TCP Nagle算法和延迟确认Delayed ACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E5%AF%B9%E6%AF%94"><span class="toc-number">2.4.</span> <span class="toc-text">TCP和UDP的区别、对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.1.</span> <span class="toc-text">主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E6%AF%94-TCP-%E6%9B%B4%E9%80%82%E5%90%88%E8%AF%AD%E9%9F%B3"><span class="toc-number">2.4.2.</span> <span class="toc-text">UDP 比 TCP 更适合语音</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.3.</span> <span class="toc-text">TCP和UDP的效率问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87%E3%80%81MTU%E3%80%81MSS"><span class="toc-number">2.5.</span> <span class="toc-text">数据包分片、MTU、MSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E5%88%86%E7%89%87%E5%92%8C%E9%87%8D%E7%BB%84"><span class="toc-number">2.5.1.</span> <span class="toc-text">数据包分片和重组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MTU%E7%9A%84%E5%AE%9E%E6%88%98"><span class="toc-number">2.5.2.</span> <span class="toc-text">MTU的实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%B5%81%E6%8E%A7%E5%92%8C%E5%B8%A6%E5%AE%BD"><span class="toc-number">2.6.</span> <span class="toc-text">特殊的流控和带宽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Wireshark%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%E8%AE%BA"><span class="toc-number">3.</span> <span class="toc-text">Wireshark分析方法论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/24/2022-10-24_os_course_introduction/" title="MIT 6.s81课程学习(1) —— 简介"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg'" alt="MIT 6.s81课程学习(1) —— 简介"/></a><div class="content"><a class="title" href="/2022/10/24/2022-10-24_os_course_introduction/" title="MIT 6.s81课程学习(1) —— 简介">MIT 6.s81课程学习(1) —— 简介</a><time datetime="2022-10-23T23:18:16.000Z" title="发表于 2022-10-24 07:18:16">2022-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/21/2022-07-21-wireshark-for-tcp/" title="Wireshark分析艺术【转载】"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg'" alt="Wireshark分析艺术【转载】"/></a><div class="content"><a class="title" href="/2022/07/21/2022-07-21-wireshark-for-tcp/" title="Wireshark分析艺术【转载】">Wireshark分析艺术【转载】</a><time datetime="2022-07-20T23:28:16.000Z" title="发表于 2022-07-21 07:28:16">2022-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/30/2022-05-30-aarch64-qemu-linux/" title="基于QEMU的AArch64仿真环境运行Linux平台搭建"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg'" alt="基于QEMU的AArch64仿真环境运行Linux平台搭建"/></a><div class="content"><a class="title" href="/2022/05/30/2022-05-30-aarch64-qemu-linux/" title="基于QEMU的AArch64仿真环境运行Linux平台搭建">基于QEMU的AArch64仿真环境运行Linux平台搭建</a><time datetime="2022-05-29T23:02:16.000Z" title="发表于 2022-05-30 07:02:16">2022-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/24/2022-05-24-ICS-Introduction/" title="1 - ICS简介"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg'" alt="1 - ICS简介"/></a><div class="content"><a class="title" href="/2022/05/24/2022-05-24-ICS-Introduction/" title="1 - ICS简介">1 - ICS简介</a><time datetime="2022-05-24T00:02:16.000Z" title="发表于 2022-05-24 08:02:16">2022-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/23/2022-05-23-signal-processing-study/" title="信号处理学习大纲"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg'" alt="信号处理学习大纲"/></a><div class="content"><a class="title" href="/2022/05/23/2022-05-23-signal-processing-study/" title="信号处理学习大纲">信号处理学习大纲</a><time datetime="2022-05-22T23:40:16.000Z" title="发表于 2022-05-23 07:40:16">2022-05-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By XiaoEr</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>